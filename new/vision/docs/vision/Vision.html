<!DOCTYPE html>
<html lang="en"><!-- use theme color or fallback -->
<!--use textcolor from settings, otherwise create a contrasting color to theme color-->
<head><meta charset="utf-8"/><link href="../bootstrap/css/bootstrap.min.css" rel="stylesheet"/><link href="../bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet"/><link href="../bootstrap/css/bootstrap-select.min.css" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700,700italic,400italic" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600,600italic,400" rel="stylesheet" type="text/css"/><link href="https://netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.css" rel="stylesheet" type="text/css"/><script src="../jquery-3.6.0.min.js"></script><script src="../bootstrap/js/bootstrap.min.js"></script><script src="../bootstrap/js/bootstrap-select.min.js"></script><link href="../styles.css" rel="stylesheet"/><link href="../extra-styles.css" rel="stylesheet"/><link href="../haxe-nav.css" rel="stylesheet"/><link href="../dark-mode.css" rel="stylesheet"/><script>var dox = {rootPath: "../",platforms: ["js"]};</script><script src="../nav.js"></script><script src="../index.js"></script><link rel="icon" href="../favicon.ico" type="image/x-icon"/><title>vision.Vision</title><meta name="description" content="The class where all image manipulation &amp;amp; computer vision functions are stored."/></head><body><script>/* Here to prevent flash of unstyled content */let systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;if ((!localStorage.theme && systemDarkMode) || localStorage.theme == "dark") {document.body.style.backgroundColor = "#111";document.body.style.opacity = "0";document.addEventListener("DOMContentLoaded", function(event) {toggleTheme();document.body.style.backgroundColor = "";document.body.style.opacity = "";});}</script><style>
.navbar .brand {
	display: inline-block;
	float: none;
	text-shadow: 0 0 0 transparent;
}
</style><nav class="nav"><div class="navbar"><div class="navbar-inner" style="background:#FAFAFA; border-bottom:1px solid rgba(0,0,0,.09)"><div class="container"><a class="brand" style="color:#000000" href="../">API Documentation</a><a href="#" id="theme-toggle" class="brand" style="color:#000000" onclick="toggleTheme()" title="Toggle Dark Mode"><i class="fa fa-moon-o"></i></a></div></div></div></nav><div class="container main-content"><div class="row-fluid"><div class="span3"><div class="well sidebar-nav"><form class="form-search" id="searchForm"><div class="input-prepend input-block-level"><span class="add-on"><i class="fa fa-search"></i></span><input id="search" type="text" placeholder="Filter (Ctrl+P)" autocomplete="off"/></div></form></div><div class="well sidebar-nav" id="explorer"><div id="nav"></div></div></div><div class="span9"><div class="page-header"><h1><small>class</small> Vision</h1><h4><small>package <a href="../vision/index.html">vision</a></small></h4>    <span class="label label-meta label-meta-directlyUsed" title="Marks types that are directly referenced by non-extern code.">@:directlyUsed</span></div><div class="body"><div class="doc doc-main"><p>The class where all image manipulation &amp; computer vision functions are stored.</p>
<p>If you're going to make extensive use of this class, it is recommended to use this as a static extension:</p>
<pre><code class="prettyprint haxe">using vision.Vision;</code></pre></div><h3 class="section">Static methods</h3><div class="fields"><div class="field "><a name="affineTransform"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ originMode : CENTER, expansionMode : RESIZE })</span><span class="label label-static">static</span><a href="#affineTransform"><span class="identifier">affineTransform</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">?matrix:<a class="type" title="vision.ds.TransformationMatrix2D" href="../vision/ds/TransformationMatrix2D.html">TransformationMatrix2D</a>,</span> <span style="white-space:nowrap">expansionMode:<a class="type" title="vision.ds.specifics.ImageExpansionMode" href="../vision/ds/specifics/ImageExpansionMode.html">ImageExpansionMode</a> = RESIZE,</span> <span style="white-space:nowrap">?originPoint:<a class="type" title="vision.ds.Point2D" href="../vision/ds/Point2D.html">Point2D</a>,</span> <span style="white-space:nowrap">originMode:<a class="type" title="vision.ds.specifics.TransformationMatrixOrigination" href="../vision/ds/specifics/TransformationMatrixOrigination.html">TransformationMatrixOrigination</a> = CENTER</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Manipulates the image's pixel data by applying the given transformation matrix - 
a 3x3 "grid" used to Move the image's pixels from one position to another. </p>
<p>The given transformation matrix must be one that maps one parallel line to another. 
The clearest indicator of this is an empty last row, aside from a <code>1</code> at the end.</p>
<p>Differs from <code><a href="../vision/Vision.html#convolve">Vision.convolve</a></code> in that it doesn't change the pixels color (like a <code>BoxBlur</code>, for example), but instead modifies the position of pixels within the image.<br />
This makes it easy to rotate, scale or translate an image.</p>
<p>A matrix can be a literal 2D array: <code>[[1, 0, 0], [0, 1, 0], [0, 0, 1]]</code>, an instance of <code><a href="../vision/ds/Array2D.html#Array2D">Array2D</a></code>, 
an instance of <code><a href="../vision/ds/Matrix2D.html#Matrix2D">Matrix2D</a></code>, or one of our home-made matrices using the static properties on <code><a href="../vision/ds/Matrix2D.html#Matrix2D">Matrix2D</a></code> :).</p>
<p><strong>Some things to note:</strong>
- The matrix's size must be 3x3. If the matrix is not 3x3, an error will be thrown.
- Some transformations can move pixels outside of the image's original bounds 
(for example, rotation, translation)), so, depending on the value of <code>expandImageBounds</code>, the image may resize.
- If you want to know how the pixel position-manipulation is done, see <code><a href="../vision/ds/Matrix2D.html#Matrix2D">Matrix2D</a></code>'s documentation.</p>
<p>Examples for some of the pre-made matrices:</p><table><thead><th>Original</th><th>Shearing</th><th>Rotation</th><th>Rotation (<code>!expandImageBounds</code>)</th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-affineTransformShear.png" alt="Sheared" /></td><td><img src="https://spacebubble.io/vision/docs/valve-affineTransformRotate%28expandImageBounds%20=%20true%29.png" alt="Rotated, expanded" /></td><td><img src="https://spacebubble.io/vision/docs/valve-affineTransformRotate%28expandImageBounds%20=%20false%29.png" alt="Rotated, original size" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to manipulate.</p></td></tr><tr><th style="width:25%;"><code>matrix</code></th><td><p>a transformation matrix to use when manipulating the image. expects a 3x3 matrix. any other size may throw an error.</p></td></tr><tr><th style="width:25%;"><code>expansionMode</code></th><td><p>how to expand the image if the matrix moves the image outside of its original bounds, or never reaches the original bounds. Defaults to <code><a href="../vision/ds/specifics/ImageExpansionMode.html#SAME_SIZE">ImageExpansionMode.SAME_SIZE</a></code>.</p></td></tr><tr><th style="width:25%;"><code>originPoint</code></th><td><p><strong>OPTION 1</strong>: the point in the image to use as the origin of the transformation matrix. Before a point is passed to the matrix, it's coordinates are incremented by this point, and after the matrix is applied, it's coordinates are decremented by this point. Useful for rotation transformations. Defaults to <code>(0, 0)</code>.</p></td></tr><tr><th style="width:25%;"><code>originMode</code></th><td><p><strong>OPTION 2</strong>: To avoid bloat, you can provide a pre-made representation of the origin point, via <code><a href="../vision/ds/specifics/TransformationMatrixOrigination.html#TransformationMatrixOrigination">TransformationMatrixOrigination</a></code> enum. Defaults to <code><a href="../vision/ds/specifics/TransformationMatrixOrigination.html#TOP_LEFT">TransformationMatrixOrigination.TOP_LEFT</a></code>.</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A new, manipulated image. The provided image remains unchanged.</p></div><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>MatrixMultiplicationError</code></th><td><p>if the size of the given matrix is not 3x3.</p></td></tr></table><p class="javadoc">See also:</p><ul><li><div class="inline-content"><p><code><a href="../vision/Vision.html#convolve">Vision.convolve</a>()</code> for color-manipulation matrices (or, kernels).</p></div></li><li><div class="inline-content"><p><code><a href="../vision/Vision.html#perspectiveWarp">Vision.perspectiveWarp</a>()</code> for "3d" manipulations.</p></div></li></ul></div></div><div class="field "><a name="barrelDistortion"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ strength : 0.2 })</span><span class="label label-static">static</span><a href="#barrelDistortion"><span class="identifier">barrelDistortion</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">strength:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../Float.html">Float</a> = 0.2</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p></p></div></div><div class="field "><a name="bilateralDenoise"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ intensitySigma : 50, gaussianSigma : 0.8 })</span><span class="label label-static">static</span><a href="#bilateralDenoise"><span class="identifier">bilateralDenoise</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">gaussianSigma:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../Float.html">Float</a> = 0.8,</span> <span style="white-space:nowrap">intensitySigma:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../Float.html">Float</a> = 50</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Applies the Bilateral Filter to the given image.<br />
The bilateral filter denoises an image by using a "blur", 
similar to the gaussian blur, but it differs from the gaussian blur 
by assigning different weights &amp; intensities to different pixels, 
depending on their color differences, and not only their positions.</p><table><thead><th>Original</th><th>Sharpened</th><th>Sharpened (Denoised)</th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-sharpen.png" alt="After" /></td><td><img src="https://spacebubble.io/vision/docs/valve-bilateralDenoise.png" alt="After" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to operate on.</p></td></tr><tr><th style="width:25%;"><code>gaussianSigma</code></th><td><p>The sigma to use when generating the gaussian kernel. This also decides the size of the kernel (The size of the kernel is always <code><a href="../Math.html#round">Math.round</a>(6 * gaussianSigma)</code>, and gets incremented if the resulting size is even)</p></td></tr><tr><th style="width:25%;"><code>intensitySigma</code></th><td><p>The intensity sigma decides how hard should the algorithm "try" to reduce the noise inside the image. A higher value causes a pixel that has vastly different color than it's surrounding to weigh much less, and pretty much get "ignored and overwritten". **tl;dr - a higher value reduces more noise, but may blur the image if too high.</p></td></tr></table></div></div><div class="field "><a name="blackAndWhite"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ threshold : 128 })</span><span class="label label-static">static</span><a href="#blackAndWhite"><span class="identifier">blackAndWhite</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">threshold:<a class="type" title="Int - The standard Int type." href="../Int.html">Int</a> = 128</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Converts an image to COMPLETE black and white.</p>
<p>It does so by taking the color channel with the highest value, and checking if that maximum surpasses <code>threshold</code>.</p><table><thead><th>Original</th><th><code>threshold = 128</code></th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-blackAndWhite.png" alt="After" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to be converted.</p></td></tr><tr><th style="width:25%;"><code>threshold</code></th><td><p>The threshold for converting to black and white: <code>threshold</code> is the maximum average of the three color components, that will still be considered black. <code>threshold</code> is a value between 0 and 255. The higher the value, the more "sensitive" the conversion. The default value is 128.</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The converted image.</p></div></div></div><div class="field "><a name="cannyEdgeDetection"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ highThreshold : 0.2, lowThreshold : 0.05, kernelSize : X5, sigma : 1 })</span><span class="label label-static">static</span><a href="#cannyEdgeDetection"><span class="identifier">cannyEdgeDetection</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">sigma:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../Float.html">Float</a> = 1,</span> <span style="white-space:nowrap">kernelSize:<a class="type" title="vision.ds.gaussian.GaussianKernelSize" href="../vision/ds/gaussian/GaussianKernelSize.html">GaussianKernelSize</a> = X5,</span> <span style="white-space:nowrap">lowThreshold:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../Float.html">Float</a> = 0.05,</span> <span style="white-space:nowrap">highThreshold:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../Float.html">Float</a> = 0.2</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Uses Canny's edge multi stage edge detection algorithm to detect edges in an image,
while reducing noise.</p>
<p>This algorithm works by first applying a gaussian blur to the image, and then
applying more filters to differentiate between strong edges, weak edges and non-edges.</p>
<p>Example:</p><table><thead><th>Original</th><th align="center">Edge Detected (default settings)</th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td align="center"><img src="https://spacebubble.io/vision/docs/valve-cannyEdgeDetection.png" alt="After" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to be edge detected.</p></td></tr><tr><th style="width:25%;"><code>sigma</code></th><td><p>The sigma value to be used in the gaussian blur.</p></td></tr><tr><th style="width:25%;"><code>kernelSize</code></th><td><p>This is used for the second step of the canny edge detection - gaussian blur. Unless you want to improve performance, this should remain unchanged.</p></td></tr><tr><th style="width:25%;"><code>lowThreshold</code></th><td><p>The low threshold value to be used in the hysteresis thresholding.</p></td></tr><tr><th style="width:25%;"><code>highThreshold</code></th><td><p>The high threshold value to be used in the hysteresis thresholding.</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The edge detected image.</p></div><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>InvalidGaussianKernelSize</code></th><td><p>thrown if the <code>kernelSize</code> is negative/divisible by <code>2</code>.</p></td></tr></table></div></div><div class="field "><a name="combine"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ percentage : 50 })</span><span class="label label-static">static</span><a href="#combine"><span class="identifier">combine</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">?with:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">percentage:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../Float.html">Float</a> = 50</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Combines two images by averaging out the values of each pixel's color channels, according to <code>percentage</code>.</p>
<p>The images can be of different sizes. </p><table><thead><th>Original</th><th>Combined With Default</th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-combine.png" alt="After" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to combine on. When this function returns, that image should be modified</p></td></tr><tr><th style="width:25%;"><code>with</code></th><td><p>The second image to combine with. That image is preserved throughout the function.</p></td></tr><tr><th style="width:25%;"><code>percentage</code></th><td><p>The ratio between the contributions of each pixel within the two images, from 0 to 100: a lower value will make the first image's pixels contribute more to the the final image, thus making that image more similar to the first image, and vice-versa.</p></td></tr></table></div></div><div class="field "><a name="contrast"></a><h3 class="anchor"><code><span class="label label-static">static</span><a href="#contrast"><span class="identifier">contrast</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Gets a contrast-enhanced version of an image,
with more exaggerated colors.</p><table><thead><th>Original</th><th>Processed</th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-contrast.png" alt="After" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to be contrasted.</p></td></tr></table></div></div><div class="field "><a name="convolutionRidgeDetection"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ refine : false, normalizationRangeEnd : 0xFFBBBBBB, normalizationRangeStart : 0xFF444444 })</span><span class="label label-static">static</span><a href="#convolutionRidgeDetection"><span class="identifier">convolutionRidgeDetection</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">normalizationRangeStart:<a class="type" title="vision.ds.Color" href="../vision/ds/Color.html">Color</a> = 0xFF444444,</span> <span style="white-space:nowrap">normalizationRangeEnd:<a class="type" title="vision.ds.Color" href="../vision/ds/Color.html">Color</a> = 0xFFBBBBBB,</span> <span style="white-space:nowrap">refine:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../Bool.html">Bool</a> = false</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Uses a fast, convolution-based method to detect ridges within an image.</p>
<p>It does the detection by grayscaling &amp; normalizing the image, and then
convolving it with a ridge detection kernel.</p>
<p>Useful as a fast alternative to other <strong>edge</strong> detection algorithms, since it usually
produces the most accurate edge representation while being the fastest (<code>1.5x</code> faster than sobel &amp; perwitt, 
exponentially faster than canny (image size dependent)).  </p>
<p><strong>Comparison:</strong></p><table><thead><th align="center">Algorithm</th><th>Output</th><th align="center">Time Complexity</th></thead><tbody><tr><td align="center">None</td><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Perwitt Edge Detection" /></td><td align="center">-</td></tr><tr><td align="center"><strong><code>perwittEdgeDetection</code></strong></td><td><img src="https://spacebubble.io/vision/docs/valve-perwittEdgeDetection.png" alt="Perwitt Edge Detection" /></td><td align="center"><code>O(width*height)</code></td></tr><tr><td align="center"><strong><code>sobelEdgeDetection</code></strong></td><td><img src="https://spacebubble.io/vision/docs/valve-sobelEdgeDetection.png" alt="Sobel Edge Detection" /></td><td align="center"><code>O(width*height)</code></td></tr><tr><td align="center"><strong><code>cannyEdgeDetection</code></strong></td><td><img src="https://spacebubble.io/vision/docs/valve-cannyEdgeDetection.png" alt="Perwitt Edge Detection" /></td><td align="center"><code>O(width*height log(width* height))</code></td></tr><tr><td align="center"><strong><code>convolutionRidgeDetection</code></strong></td><td><img src="https://spacebubble.io/vision/docs/valve-convolutionRidgeDetection.png" alt="Perwitt Edge Detection" /></td><td align="center"><code>O(width*height)</code></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>the image to be ridge detected on.</p></td></tr><tr><th style="width:25%;"><code>normalizationRangeStart</code></th><td><p>Optional, if you want to change the normalization range's start color. <code>0x44444444</code> by default.</p></td></tr><tr><th style="width:25%;"><code>normalizationRangeEnd</code></th><td><p>Optional, if you want to change the normalization range's end color <code>0xBBBBBBBB</code> by default.</p></td></tr><tr><th style="width:25%;"><code>refine</code></th><td><p>Appends an iterative pixel check to the algorithm, which removes isolated ridge pixels. <code><a href="../Bool.html">false</a></code> by default for performance reasons.</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The ridge-highlighted version of the image. <strong>The original copy is preserved</strong>.</p></div></div></div><div class="field "><a name="convolve"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ kernel : Identity })</span><span class="label label-static">static</span><a href="#convolve"><span class="identifier">convolve</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">kernel:<a class="type" title="haxe.extern.EitherType - An abstract type allowing values to be either of T1 or T2 type." href="../haxe/extern/EitherType.html">EitherType</a>&lt;<a class="type" title="vision.ds.Kernel2D" href="../vision/ds/Kernel2D.html">Kernel2D</a>, <a class="type" title="Array - An Array is a storage for values." href="../Array.html">Array</a>&lt;<a class="type" title="Array - An Array is a storage for values." href="../Array.html">Array</a>&lt;<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../Float.html">Float</a>&gt;&gt;&gt; = Identity</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>manipulates the image's pixel data by passing the pixels' value through a kernel.</p>
<p>This is useful for many things, such as simple blurring, sharpening, noise maps, and more that comes to mind :).</p>
<p>There are a couple of preexisting matrices you can use, and also a custom tool to let you create your own kernels from scratch using enums.</p>
<h3>How does this work?</h3>
<p>simply put, it takes each pixel, and multiples its surrounding pixels by the values you give the matrix.</p>
<p>In the following demo, you can see how convolution works for the <code>Sharpen</code> matrix:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/19/2D_Convolution_Animation.gif/220px-2D_Convolution_Animation.gif" alt="Sharpen Convolution" /></p><ol><li>multiply the current pixel's value by the value of the center of the matrix</li><li>multiply the current pixel's immediate neighbors (vertical/horizontal) by the matching value on the matrix 
(the pixel to the right of the current pixel will be multiplied by the value to the right of the center of the matrix)</li><li>do the same thing with the other neighbors</li><li>enjoy your convolved image :)</li></ol><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>the image to be manipulated</p></td></tr><tr><th style="width:25%;"><code>kernel</code></th><td><p>the type/value of the kernel. can be: <strong><code>Identity</code></strong>, <strong><code>BoxBlur</code></strong>, <strong><code>RidgeDetection</code></strong>, <strong><code>Sharpen</code></strong>, <strong><code>UnsharpMasking</code></strong>, <strong><code>Assemble3x3</code></strong>, <strong><code>Assemble5x5</code></strong>,
or just a matrix: both <code>convolve(image, BoxBlur)</code> and <code>convolve(image, [[1,1,1],[1,1,1],[1,1,1]])</code> are valid ways to represent a box blur.</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A convolved version of the image. The original image is not preserved.</p></div></div></div><div class="field "><a name="deepfry"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ iterations : 2 })</span><span class="label label-static">static</span><a href="#deepfry"><span class="identifier">deepfry</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">iterations:<a class="type" title="Int - The standard Int type." href="../Int.html">Int</a> = 2</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Deepfries an image by running to through a sharpening filter <code>iterations</code> times.</p>
<p>Example:</p><table><thead><th>Original</th><th><code>iterations = 1</code></th><th><code>iterations = 2</code></th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-sharpen.png" alt="After One Iteration" /></td><td><img src="https://spacebubble.io/vision/docs/valve-deepfry.png" alt="After Two Iterations" /></td></tr></tbody></table>
<p>The higher the value, the more deepfried the image will look.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to be deepfried.</p></td></tr><tr><th style="width:25%;"><code>iterations</code></th><td><p>The amount of times the image gets sharpened. default is <code>2</code>.</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The deepfried image. The original copy is not preserved.</p></div></div></div><div class="field "><a name="dilate"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ circularKernel : true, colorImportanceOrder : RedGreenBlue, dilationRadius : 2 })</span><span class="label label-static">static</span><a href="#dilate"><span class="identifier">dilate</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">dilationRadius:<a class="type" title="Int - The standard Int type." href="../Int.html">Int</a> = 2,</span> <span style="white-space:nowrap">colorImportanceOrder:<a class="type" title="vision.ds.specifics.ColorImportanceOrder" href="../vision/ds/specifics/ColorImportanceOrder.html">ColorImportanceOrder</a> = RedGreenBlue,</span> <span style="white-space:nowrap">circularKernel:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../Bool.html">Bool</a> = true</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Loops over the given image's pixels with a kernel, and replaces the center pixel of that kernel with the "maximum value" inside that kernel:</p>
<p><strong>What does replacing with the maximum value mean?</strong></p>
<p>Basically, if a nearby pixel is lighter than the current pixel, the current pixel is replaced with the lighter pixel.
That check is applied to all neighboring pixels, resulting in each pixel's color being the lightest color in its surroundings. </p>
<p><strong>example:</strong> an image being dilated with a 5x5 square kernel. you should see how each time the kernel moves, it picks the lightest colors inside of it, and continues.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/70/Grayscale_Morphological_Dilation.gif/220px-Grayscale_Morphological_Dilation.gif" alt="example" /></p><table><thead><th>Original</th><th>Dilated</th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-dilate.png" alt="After" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to operate on.</p></td></tr><tr><th style="width:25%;"><code>dilationRadius</code></th><td><p>The radius of the kernel used for the dilation process. The radius does not include the center pixel, so a radius of <code>2</code> should give a <code>5x5</code> kernel. The higher this value, the further each pixel checks for a nearby lighter pixel.</p></td></tr><tr><th style="width:25%;"><code>colorImportanceOrder</code></th><td><p>Since there may be conflicts when calculating the difference in lightness between colors with similar values in different color channels (e.g. <code>0xFF0000</code> and <code>0x0000FF</code> - channel values are "similar", colors are not), this parameter is used to favor the given color channels. The default is <code>RedGreenBlue</code> - <code>red</code> is the most important, and is considered the "lightest", followed by green, and blue is considered the "darkest".</p></td></tr><tr><th style="width:25%;"><code>circularKernel</code></th><td><p>When enabled, the kernel used to loop over the pixels becomes circular instead of being a square. This results in a slight performance increase, and a massive quality increase. Turned on by default.</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The dilated image. The original copy is not preserved.</p></div></div></div><div class="field "><a name="dropOutNoise"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ threshold : 128, percentage : 5 })</span><span class="label label-static">static</span><a href="#dropOutNoise"><span class="identifier">dropOutNoise</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">percentage:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../Float.html">Float</a> = 5,</span> <span style="white-space:nowrap">threshold:<a class="type" title="Int - The standard Int type." href="../Int.html">Int</a> = 128</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Applies noise to an image, in a "drop-out" fashion:</p>
<p>every <code>100 / percentage</code> pixels or so, a pixel is set to either black or white, 
depending on the pixel it replaces - a lighter pixel is replaced by black, 
while a darker pixel is replaced by white.</p><table><thead><th>Original</th><th>Processed</th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-dropOutNoise.png" alt="After" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to apply salt&amp;pepper noise on</p></td></tr><tr><th style="width:25%;"><code>percentage</code></th><td><p>How much of the image should be "corrupted", in percentages between 0 to 100 - 0 means no change, 100 means fully "corrupted". Default is 5</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The noisy image. The original copy is not preserved.</p></div></div></div><div class="field "><a name="erode"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ circularKernel : true, colorImportanceOrder : RedGreenBlue, erosionRadius : 2 })</span><span class="label label-static">static</span><a href="#erode"><span class="identifier">erode</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">erosionRadius:<a class="type" title="Int - The standard Int type." href="../Int.html">Int</a> = 2,</span> <span style="white-space:nowrap">colorImportanceOrder:<a class="type" title="vision.ds.specifics.ColorImportanceOrder" href="../vision/ds/specifics/ColorImportanceOrder.html">ColorImportanceOrder</a> = RedGreenBlue,</span> <span style="white-space:nowrap">circularKernel:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../Bool.html">Bool</a> = true</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Loops over the given image's pixels with a kernel, and replaces the center pixel of that kernel with the "minimum value" inside that kernel:</p>
<p><strong>What does replacing with the minimum value mean?</strong></p>
<p>Basically, if a nearby pixel is darker than the current pixel, the current pixel is replaced with the darker pixel.
That check is applied to all neighboring pixels, resulting in each pixel's color being the darkest color in its surroundings. </p>
<p><strong>example:</strong> an image being eroded with a square 5x5 kernel. You should see how each time the kernel moves, it picks the darkest colors inside of it, and continues.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b9/Grayscale_Morphological_Erosion.gif/220px-Grayscale_Morphological_Erosion.gif" alt="example" /></p><table><thead><th>Original</th><th>Eroded</th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-erode.png" alt="After" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to operate on.</p></td></tr><tr><th style="width:25%;"><code>dilationRadius</code></th><td><p>The radius of the kernel used for the erosion process. The radius does not include the center pixel, so a radius of <code>2</code> should give a <code>5x5</code> kernel. The higher this value, the further each pixel checks for a nearby darker pixel.</p></td></tr><tr><th style="width:25%;"><code>colorImportanceOrder</code></th><td><p>Since there may be conflicts when calculating the difference in darkness between colors with similar values in different color channels (e.g. <code>0xFF0000</code> and <code>0x0000FF</code> - channel values are "similar", colors are not), this parameter is used to favor the given color channels. The default is <code>RedGreenBlue</code> - <code>red</code> is the most important, and is considered the "darkest", followed by green, and blue is considered the "lightest".</p></td></tr><tr><th style="width:25%;"><code>circularKernel</code></th><td><p>When enabled, the kernel used to loop over the pixels becomes circular instead of being a square. This results in a slight performance increase, and a massive quality increase. Turned on by default.</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The eroded image. The original copy is not preserved.</p></div></div></div><div class="field "><a name="fisheyeDistortion"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ strength : 1.5 })</span><span class="label label-static">static</span><a href="#fisheyeDistortion"><span class="identifier">fisheyeDistortion</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">strength:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../Float.html">Float</a> = 1.5</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p></p></div></div><div class="field "><a name="gaussianBlur"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ fast : false, kernelSize : GaussianKernelSize.X5, sigma : 1 })</span><span class="label label-static">static</span><a href="#gaussianBlur"><span class="identifier">gaussianBlur</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">sigma:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../Float.html">Float</a> = 1,</span> <span style="white-space:nowrap">kernelSize:<a class="type" title="vision.ds.gaussian.GaussianKernelSize" href="../vision/ds/gaussian/GaussianKernelSize.html">GaussianKernelSize</a> = GaussianKernelSize.X5,</span> <span style="white-space:nowrap">fast:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../Bool.html">Bool</a> = false</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Uses the gaussian blur algorithm to blur an image.</p>
<p>This algorithm works by creating a 5x5 (thats the default size) matrix, and then applying
the gaussian distribution function to that matrix.</p>
<p>That matrix will go over each pixel and decide it's color based on the values of 
the pixels covered by the 5x5 matrix, and the <a href="https://en.wikipedia.org/wiki/Gaussian_function">gaussian distribution function</a>.</p>
<p>You can modify the values of the matrix by passing a float to the <code>sigma</code> parameter.
The higher the value of <code>sigma</code>, the blurrier the image:</p><table><thead><th>Original</th><th><code>sigma = 0.5</code></th><th><code>sigma = 1</code></th><th><code>sigma = 1</code>, <code>fast = <a href="../Bool.html">true</a></code></th><th><code>sigma = 2</code></th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-gaussianBlur%28sigma%20=%200.5%29.png" alt="After" /></td><td><img src="https://spacebubble.io/vision/docs/valve-gaussianBlur%28sigma%20=%201%29.png" alt="After" /></td><td><img src="https://spacebubble.io/vision/docs/valve-gaussianBlur%28sigma%20=%201%47%20fast%20=%20true%29.png" alt="After" /></td><td><img src="https://spacebubble.io/vision/docs/valve-gaussianBlur%28sigma%20=%202%29.png" alt="After" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to be blurred.</p></td></tr><tr><th style="width:25%;"><code>sigma</code></th><td><p>The sigma value to use for the gaussian distribution on the kernel. a lower value will focus more on the center pixel, while a higher value will shift focus to the surrounding pixels more, effectively blurring it better.</p></td></tr><tr><th style="width:25%;"><code>kernelSize</code></th><td><p>The size of the kernel (<code>width</code> &amp; <code>height</code>)</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A blurred version of the image. The original image is not preserved.</p></div><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>InvalidGaussianKernelSize</code></th><td><p>if the kernel size is even, negative or <code>0</code>, this error is thrown.</p></td></tr></table></div></div><div class="field "><a name="grayscale"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ simpleGrayscale : false })</span><span class="label label-static">static</span><a href="#grayscale"><span class="identifier">grayscale</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">simpleGrayscale:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../Bool.html">Bool</a> = false</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Grayscales an image, by averaging the color channels of each pixel.</p>
<p>If for some reason, you want to get a lower quality grayscale, set <code>simpleGrayscale</code> to <code><a href="../Bool.html">true</a></code>.</p>
<p>Example:</p><table><thead><th>Original</th><th><code>simpleGrayscale</code></th><th><code>!simpleGrayscale</code> default)</th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-grayscale.png" alt="After" /></td><td><img src="https://spacebubble.io/vision/docs/valve-grayscale&amp;vision_better_grayscale.png" alt="After" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to be grayscaled.</p></td></tr><tr><th style="width:25%;"><code>simpleGrayscale</code></th><td><p>When enabled, gets the gray by averaging pixel's color-channel values, instead of using a special ratio for more accurate grayscaling. Defaults to <code><a href="../Bool.html">false</a></code>.</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The grayscaled image.</p></div></div></div><div class="field "><a name="invert"></a><h3 class="anchor"><code><span class="label label-static">static</span><a href="#invert"><span class="identifier">invert</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Inverts an image.</p>
<p>Inversion is just flipping the values of each color channel - <code>0xFFFFFF</code> will turn into <code>0x000000</code>, <code>0xFF00FF</code> will turn into <code>0x00FF00</code>, etc.</p>
<p>The math behind inversion is just subtracting the current value of the channel from <code>0xFF</code>:</p><table><thead><th align="center">Color</th><th align="center">Process</th><th align="center">Result</th></thead><tbody><tr><td align="center"><code>0xFFFF00</code></td><td align="center">FF - FF = <strong><code>00</code></strong>, FF - FF = <strong><code>00</code></strong>, FF - 00 = <strong><code>FF</code></strong></td><td align="center"><code>0x0000FF</code></td></tr><tr><td align="center"><code>0xB13FFF</code></td><td align="center">FF - B1 = <strong><code>E4</code></strong>, FF - 3F = <strong><code>C0</code></strong>, FF - FF = <strong><code>00</code></strong></td><td align="center"><code>0xE4C000</code></td></tr></tbody></table>
<p>Example:</p><table><thead><th>Original</th><th>Inverted</th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-invert.png" alt="After" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to be inverted.</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The inverted image.</p></div></div></div><div class="field "><a name="laplacianEdgeDiffOperator"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ filterPositive : true })</span><span class="label label-static">static</span><a href="#laplacianEdgeDiffOperator"><span class="identifier">laplacianEdgeDiffOperator</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">filterPositive:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../Bool.html">Bool</a> = true</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Applies the laplacian filter to an image.</p>
<p>The image doesn't have to get grayscaled before being passed 
to this function.</p>
<p>It is different from the <code>perwittEdgeDetection</code> function, since
it doesn't try to threshold the resulting image to extract the strong edges,
and leaves that information in. Example of this filter in action:</p><table><thead><th>Original</th><th>After Filtering (Positive)</th><th>After Filtering (Negative)</th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-laplacianEdgeDiffOperator%28filterPositive%20=%20true%29.png" alt="After" /></td><td><img src="https://spacebubble.io/vision/docs/valve-laplacianEdgeDiffOperator%28filterPositive%20=%20false%29.png" alt="After" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to be operated on</p></td></tr><tr><th style="width:25%;"><code>filterPositive</code></th><td><p>Which version of the laplacian filter should the function use: the negative (detects "outward" edges), or the positive (detects "inward" edges). Default is positive (<code><a href="../Bool.html">true</a></code>).</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A new image, containing the gradients of the edges as whitened pixels.</p></div></div></div><div class="field "><a name="laplacianOfGaussianEdgeDetection"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ kernelSize : X3, sigma : 1, filterPositive : true, threshold : 2 })</span><span class="label label-static">static</span><a href="#laplacianOfGaussianEdgeDetection"><span class="identifier">laplacianOfGaussianEdgeDetection</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">threshold:<a class="type" title="Int - The standard Int type." href="../Int.html">Int</a> = 2,</span> <span style="white-space:nowrap">filterPositive:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../Bool.html">Bool</a> = true,</span> <span style="white-space:nowrap">sigma:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../Float.html">Float</a> = 1,</span> <span style="white-space:nowrap">kernelSize:<a class="type" title="vision.ds.gaussian.GaussianKernelSize" href="../vision/ds/gaussian/GaussianKernelSize.html">GaussianKernelSize</a> = X3</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Detects edges within an image, using a gaussian blur &amp; the laplacian filter.</p>
<p>This algorithm works a bit like a combination of canny &amp; perwitt edge detection, by blurring the image first to remove noise, and then
going over the image with a kernel. With the default settings. This algorithm is the fastest when working with smaller images.</p>
<p>There's no need to pre-process the image, just throw it into the function it will do the rest
(ie. the image doesn't need to be grayscale/black and white):</p><table><thead><th>Original</th><th>After Filtering (Positive)</th><th>After Filtering (Negative)</th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-laplacianOfGaussianEdgeDetection%28filterPositive%20=%20true%29.png" alt="After" /></td><td><img src="https://spacebubble.io/vision/docs/valve-laplacianOfGaussianEdgeDetection%28filterPositive%20=%20true%29.png" alt="After" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to be processed.</p></td></tr><tr><th style="width:25%;"><code>threshold</code></th><td><p>The threshold for detecting edges. The lower the value, the more pixels will be considered edges. Default is <code>5</code>.</p></td></tr><tr><th style="width:25%;"><code>filterPositive</code></th><td><p>Which version of the laplacian filter should the function use: the negative (detects "outward" edges), or the positive (detects "inward" edges). Default is positive (<code><a href="../Bool.html">true</a></code>).</p></td></tr><tr><th style="width:25%;"><code>sigma</code></th><td><p>The sigma value to use for the gaussian blur. A lower value will focus the kernel more on the center pixel, while a higher value will shift focus to the surrounding pixels more. <strong>The higher the value, the blurrier the image.</strong> Default is <code>1</code>.</p></td></tr><tr><th style="width:25%;"><code>kernelSize</code></th><td><p>The size of the kernel (<code>width</code> &amp; <code>height</code>) - a kernel size of <code>7</code>/ will produce a <code>7x7</code> kernel. Default is <code><a href="../vision/ds/gaussian/GaussianKernelSize.html#X3">GaussianKernelSize.X3</a></code>.</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A new, black and white image, with white pixels being the detected edges.</p></div></div></div><div class="field "><a name="limitColorRanges"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ rangeEnd : 0xFFFFFFFF, rangeStart : 0x00000000 })</span><span class="label label-static">static</span><a href="#limitColorRanges"><span class="identifier">limitColorRanges</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">rangeStart:<a class="type" title="vision.ds.Color" href="../vision/ds/Color.html">Color</a> = 0x00000000,</span> <span style="white-space:nowrap">rangeEnd:<a class="type" title="vision.ds.Color" href="../vision/ds/Color.html">Color</a> = 0xFFFFFFFF</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Limits the range of colors on an image, by limiting the range of a given color channel, according to the values
of <code>rangeStart</code>'s and <code>rangeEnd</code>'s color channels.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to be li processed.</p></td></tr><tr><th style="width:25%;"><code>rangeStart</code></th><td><p>The start of the range of channels. By default, this value is <code>0x00000000</code></p></td></tr><tr><th style="width:25%;"><code>rangeEnd</code></th><td><p>The end of the range of channels. By default, this value is <code>0xFFFFFFFF</code></p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The normalized image. The original copy is not preserved.</p></div></div></div><div class="field "><a name="medianBlur"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ kernelSize : 5 })</span><span class="label label-static">static</span><a href="#medianBlur"><span class="identifier">medianBlur</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">kernelSize:<a class="type" title="Int - The standard Int type." href="../Int.html">Int</a> = 5</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Applies a median filter to an image to reduce the amount of noise in that image.</p>
<p>Median filter "blurs" the image by taking a pixel &amp; its surrounding, 
finding the median of that group, and setting the center pixel to that median.</p>
<p>Example of the filter in action:</p><table><thead><th>Original</th><th><code>kernelSize = 5</code></th><th><code>kernelSize = 10</code></th><th><code>kernelSize = 15</code></th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-medianBlur%28kernelRadius%20=%205%29.png" alt="After" /></td><td><img src="https://spacebubble.io/vision/docs/valve-medianBlur%28kernelRadius%20=%2010%29.png" alt="After" /></td><td><img src="https://spacebubble.io/vision/docs/valve-medianBlur%28kernelRadius%20=%2015%29.png" alt="After" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to apply median blurring to.</p></td></tr><tr><th style="width:25%;"><code>kernelSize</code></th><td><p>the width &amp; height of the kernel in which we should search for the median. A radius of <code>9</code> will check in a <code>19x19</code> (<code>radius(9)</code> + <code>center(1)</code> + <code>radius(9)</code>) square around the center pixel.</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A filtered version of the image, using median blurring. The original image is not preserved.</p></div></div></div><div class="field "><a name="mustacheDistortion"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ amplitude : 0.2 })</span><span class="label label-static">static</span><a href="#mustacheDistortion"><span class="identifier">mustacheDistortion</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">amplitude:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../Float.html">Float</a> = 0.2</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p></p></div></div><div class="field "><a name="nearestNeighborBlur"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ iterations : 1 })</span><span class="label label-static">static</span><a href="#nearestNeighborBlur"><span class="identifier">nearestNeighborBlur</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">iterations:<a class="type" title="Int - The standard Int type." href="../Int.html">Int</a> = 1</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Uses an iterative, nearest-neighbor style algorithm to blur an image.</p>
<p>The algorithm is very simple and quite fast, but also very sensitive 
performance-wise. The maximum value recommended to use for the 
<code>iterations</code> property is 100, altho you shouldn't really find yourself using more than <code>25</code>.</p>
<p>Example:</p><table><thead><th>Original</th><th><code>iterations = 1</code></th><th><code>iterations = 4</code></th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-nearestNeighborBlur%28iterations%20=%201%29.png" alt="After" /></td><td><img src="https://spacebubble.io/vision/docs/valve-nearestNeighborBlur%28iterations%20=%204%29.png" alt="After" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to be blurred.</p></td></tr><tr><th style="width:25%;"><code>iterations</code></th><td><p>The number of times the algorithm will be run. The more iterations, the more blurry the image will be, and the higher the "blur range". <strong>For example:</strong> a value of 3 will produce a blur range of 3 pixels on each object.</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A blurred version of the image. The original image is not preserved.</p></div></div></div><div class="field "><a name="normalize"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ rangeEnd : 0xFFFFFFFF, rangeStart : 0x00000000 })</span><span class="label label-static">static</span><a href="#normalize"><span class="identifier">normalize</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">rangeStart:<a class="type" title="vision.ds.Color" href="../vision/ds/Color.html">Color</a> = 0x00000000,</span> <span style="white-space:nowrap">rangeEnd:<a class="type" title="vision.ds.Color" href="../vision/ds/Color.html">Color</a> = 0xFFFFFFFF</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Limits the range of colors on an image, by resizing the range of a given color channel, according to the values
of <code>rangeStart</code>'s and <code>rangeEnd</code>'s color channels.</p>
<h3>How Does this work?</h3><ol><li>before calculating anything, you get the min &amp; max values of each color channel from the two given colors.
For example, if <code>rangeStart</code> is <code>0xFF05F243</code> and <code>rangeEnd</code> is <code>0x239A6262</code>, the min/max values of the <code>red</code> channel 
will be set to (<code>0x05</code>, <code>0x9A</code>), the min/max values of the green channel will be set to (<code>0x62</code>, <code>0xF2</code>)...</li><li>Loop over the pixels, and calculate the ratios between the the pixel's color channel's and the values (<code>0x00</code>, <code>0xFF</code>)</li><li>Now, calculate the step between each color value of the new range, by dividing each channel's (<code>max</code> - <code>min</code>) by <code>255</code>. The
default step between each color value is <code>1</code> by default (<code>(0xFF - 0x00) / 0xFF = 1</code>).</li><li>Loop over the channels, and multiply their value by the value of the new <code>step</code> (for example, 4
<code>newStep = (0x88 - 0x00) / 0xFF = 0.5</code>, <code>color.red = color.red * newStep</code>);</li><li>enjoy your normalized image :)</li></ol><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to be normalized.</p></td></tr><tr><th style="width:25%;"><code>rangeStart</code></th><td><p>The start of the range of channels. By default, this value is <code>0x00000000</code></p></td></tr><tr><th style="width:25%;"><code>rangeEnd</code></th><td><p>The end of the range of channels. By default, this value is <code>0xFFFFFFFF</code></p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The normalized image. The original copy is not preserved.</p></div></div></div><div class="field "><a name="perwittEdgeDetection"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ threshold : 100 })</span><span class="label label-static">static</span><a href="#perwittEdgeDetection"><span class="identifier">perwittEdgeDetection</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">threshold:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../Float.html">Float</a> = 100</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Detects edges within an image.</p>
<p>Edges are detected using the Perwitt operator, going from left to right and top to bottom.</p>
<p>There's no need to pre-process the image, just throw it on it and it will do the rest
(ie. it doesn't need to be grayscaled/black and white):</p><table><thead><th>Before</th><th>After</th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-perwittEdgeDetection.png" alt="After" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to be processed.</p></td></tr><tr><th style="width:25%;"><code>threshold</code></th><td><p>The threshold for detecting edges. The lower the value, 
the more pixels will be considered edges. Default is <code>100</code></p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The image with edges detected. This image is returned as a new, black and white image.</p></div></div></div><div class="field "><a name="perwittEdgeDiffOperator"></a><h3 class="anchor"><code><span class="label label-static">static</span><a href="#perwittEdgeDiffOperator"><span class="identifier">perwittEdgeDiffOperator</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Applies the perwitt filter to an image.</p>
<p>The image doesn't have to get grayscaled before being passed 
to this function.</p>
<p>It is different from the <code>perwittEdgeDetection</code> function, since
it doesn't try to threshold the resulting image to extract the strong edges,
and leaves that information in. Example of this filter in action:</p><table><thead><th>Original</th><th>After Filtering</th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-perwittEdgeDiffOperator.png" alt="After" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to be operated on</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A new image, containing the gradients of the edges as whitened pixels.</p></div></div></div><div class="field "><a name="pincushionDistortion"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ strength : 0.2 })</span><span class="label label-static">static</span><a href="#pincushionDistortion"><span class="identifier">pincushionDistortion</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">strength:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../Float.html">Float</a> = 0.2</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p></p></div></div><div class="field "><a name="projectiveTransform"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ expansionMode : RESIZE })</span><span class="label label-static">static</span><a href="#projectiveTransform"><span class="identifier">projectiveTransform</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">?matrix:<a class="type" title="vision.ds.TransformationMatrix2D" href="../vision/ds/TransformationMatrix2D.html">TransformationMatrix2D</a>,</span> <span style="white-space:nowrap">expansionMode:<a class="type" title="vision.ds.specifics.ImageExpansionMode" href="../vision/ds/specifics/ImageExpansionMode.html">ImageExpansionMode</a> = RESIZE</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Manipulates the image's pixel data by applying the given transformation matrix - 
a 3x3 "grid" used to Move the image's pixels from one position to another. </p>
<p>Differs from <code>affineTransform()</code> in one, major way: while<code>affineTransform()</code> only supports two-dimensional, parallel-to-parallel transformations.
<code>perspectiveWarp</code> supports transformations in all three dimensions.</p>
<p>It also differs from <code><a href="../vision/Vision.html#convolve">Vision.convolve</a></code> in that it doesn't change the pixels color (like a <code>BoxBlur</code>, for example), 
but instead modifies the position of pixels within the image.</p>
<p>A matrix can be a literal 2D array: <code>[[1, 0, 0], [0, 1, 0], [0, 0, 1]]</code>, an instance of <code><a href="../vision/ds/Array2D.html#Array2D">Array2D</a></code>, 
an instance of <code><a href="../vision/ds/Matrix2D.html#Matrix2D">Matrix2D</a></code>, or one of our home-made matrices using the static properties on <code><a href="../vision/ds/Matrix2D.html#Matrix2D">Matrix2D</a></code> :).</p>
<p>Examples for some of the pre-made matrices:</p><table><thead><th>Original</th><th>Depth</th><th>Perspective</th><th>Rotation (<code>!expandImageBounds</code>)</th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-affineWarpShear.png" alt="Sheared" /></td><td><img src="https://spacebubble.io/vision/docs/valve-affineWarpRotate%28expandImageBounds%20=%20true%29.png" alt="Rotated, expanded" /></td><td><img src="https://spacebubble.io/vision/docs/valve-affineWarpRotate%28expandImageBounds%20=%20false%29.png" alt="Rotated, original size" /></td></tr></tbody></table>
<pre><code>    @param image The image to manipulate.
</code></pre><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>matrix</code></th><td><p>a transformation matrix to use when manipulating the image. expects a 3x3 matrix. any other size may throw an error.</p></td></tr></table></div></div><div class="field "><a name="replaceColorRanges"></a><h3 class="anchor"><code><span class="label label-static">static</span><a href="#replaceColorRanges"><span class="identifier">replaceColorRanges</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">?ranges:<a class="type" title="Array - An Array is a storage for values." href="../Array.html">Array</a>&lt;{replacement:<a class="type" title="vision.ds.Color" href="../vision/ds/Color.html">Color</a>, rangeStart:<a class="type" title="vision.ds.Color" href="../vision/ds/Color.html">Color</a>, rangeEnd:<a class="type" title="vision.ds.Color" href="../vision/ds/Color.html">Color</a>}&gt;</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Replaces the colors inside each range with the given color inside that range object:  </p>
<pre><code class="prettyprint haxe">[{rangeStart: 0x00000000, rangeEnd = 0x88888888, replacement: 0xFFFFFFFF}] </code></pre>
<p>will replace every pixel inside the given color range with the color <code>0xFFFFFFFF</code></p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image process.</p></td></tr><tr><th style="width:25%;"><code>ranges</code></th><td><p>array of color ranges &amp; replacement colors.</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A processed version of the image. The original image is not preserved.</p></div></div></div><div class="field "><a name="robertEdgeDiffOperator"></a><h3 class="anchor"><code><span class="label label-static">static</span><a href="#robertEdgeDiffOperator"><span class="identifier">robertEdgeDiffOperator</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Applies the Robert's Cross operator to an image.</p>
<p>The image doesn't have to get grayscaled before being passed 
to this function.</p>
<p>While being the one of the oldest forms of edge gradient operators (dates back to 1963!),
Its one of the fastest, if not <em>the</em> fastest.</p>
<p>It does have its caveats though: while generally being 2x faster, its <em>way</em> more sensitive to noise, and may produce a more "jagged" image.</p><table><thead><th>Original</th><th>After Filtering</th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-robertEdgeDiffOperator.png" alt="After" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to be operated on</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A new image, containing the gradients of the edges as whitened pixels.</p></div></div></div><div class="field "><a name="saltAndPepperNoise"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ percentage : 25 })</span><span class="label label-static">static</span><a href="#saltAndPepperNoise"><span class="identifier">saltAndPepperNoise</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">percentage:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../Float.html">Float</a> = 25</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Applies noise to an image, in a "salt &amp; pepper" fashion:</p>
<p>every <code>100 / percentage</code> pixels or so, a randomly generated mask bitmask is applied to the color, using <strong>color interpolation</strong></p><table><thead><th>Original</th><th><code>percentage = 25</code></th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-saltAndPepperNoise.png" alt="After" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to apply salt&amp;pepper noise on.</p></td></tr><tr><th style="width:25%;"><code>percentage</code></th><td><p>How much of the image should be "corrupted", in percentages between 0 to 100 - 0 means no change, 100 means fully "corrupted". Default is 25.</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The noisy image. The original copy is not preserved.</p></div><p class="javadoc">See also:</p><ul><li><div class="inline-content"><p>Color.interpolate()</p></div></li></ul></div></div><div class="field "><a name="sharpen"></a><h3 class="anchor"><code><span class="label label-static">static</span><a href="#sharpen"><span class="identifier">sharpen</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Returns a sharpened version of the provided image.</p>
<p>When an image is sharpened. it's color differences are exaggerated. The more times
the image is sharpened, the more "deepfried" it'll look.</p>
<p>Example:</p><table><thead><th>Original</th><th>Sharpened</th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-sharpen.png" alt="After" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to be contrasted.</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The sharpened image. The original copy is not preserved.</p></div></div></div><div class="field "><a name="simpleLine2DDetection"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ speedToAccuracyRatio : Medium_Intermediate, minLineLength : 10, accuracy : 50 })</span><span class="label label-static">static</span><a href="#simpleLine2DDetection"><span class="identifier">simpleLine2DDetection</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">accuracy:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../Float.html">Float</a> = 50,</span> <span style="white-space:nowrap">minLineLength:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../Float.html">Float</a> = 10,</span> <span style="white-space:nowrap">speedToAccuracyRatio:<a class="type" title="vision.ds.specifics.AlgorithmSettings" href="../vision/ds/specifics/AlgorithmSettings.html">AlgorithmSettings</a> = Medium_Intermediate</span>):<a class="type" title="Array - An Array is a storage for values." href="../Array.html">Array</a>&lt;<a class="type" title="vision.ds.Line2D" href="../vision/ds/Line2D.html">Line2D</a>&gt;</code></h3><div class="doc"><p>Uses a simple, partially recursive algorithm to detect line segments in an image.</p>
<p>those lines can be partially incomplete, but they will be detected as lines.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to be line detected.</p></td></tr><tr><th style="width:25%;"><code>accuracy</code></th><td><p>When a line is detected, the algorithm checks how much of the line actually covers a  "line portion" of the image. <code>accuracy</code> is set to <code>50</code> by default - at least half of the line has to match with the image. To optimize for line count, <code>40</code> and below is recommended. Otherwise, <code>50</code> to <code>60</code> should be fine.</p></td></tr><tr><th style="width:25%;"><code>minLineLength</code></th><td><p>The minimum length of a line segment to be detected.</p></td></tr><tr><th style="width:25%;"><code>speedToAccuracyRatio</code></th><td><p>If the algorithm is too slow/too inaccurate for you, you can change this setting.</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The line detected image.</p></div></div></div><div class="field "><a name="sobelEdgeDetection"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ threshold : 500 })</span><span class="label label-static">static</span><a href="#sobelEdgeDetection"><span class="identifier">sobelEdgeDetection</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">threshold:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../Float.html">Float</a> = 500</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Detects edges within an image.</p>
<p>Edges are detected using the Sobel operator, going from left to right and top to bottom.</p>
<p>To improve angle related errors with the sobel operator, Scharr's optimized version is used.</p>
<p>There's no need to pre-process the image, just throw it on it and it will do the rest
(ie. it doesn't need to be grayscaled/black and white):</p><table><thead><th>Before</th><th>After</th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-sobelEdgeDetection.png" alt="After" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to be processed.</p></td></tr><tr><th style="width:25%;"><code>threshold</code></th><td><p>The threshold for detecting edges. The lower the value, 
the more pixels will be considered edges. Default is <code>500</code></p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The image with edges detected. This image is returned as a new, black and white image.</p></div></div></div><div class="field "><a name="sobelEdgeDiffOperator"></a><h3 class="anchor"><code><span class="label label-static">static</span><a href="#sobelEdgeDiffOperator"><span class="identifier">sobelEdgeDiffOperator</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Applies the sobel filter to an image.</p>
<p>The image doesn't have to get grayscaled before being passed 
to this function.</p>
<p>It is different from the <code>sobelEdgeDetection</code> function, since
it doesn't try to threshold the resulting image to extract the strong edges,
and leaves that information in. Example of this filter in action:</p><table><thead><th>Original</th><th>After Filtering</th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-sobelEdgeDiffOperator.png" alt="After" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to be operated on</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A new image, containing the gradients of the edges as whitened pixels.</p></div></div></div><div class="field "><a name="whiteNoise"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ whiteNoiseRange : RANGE_16, percentage : 25 })</span><span class="label label-static">static</span><a href="#whiteNoise"><span class="identifier">whiteNoise</span></a>(<span style="white-space:nowrap">image:<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a>,</span> <span style="white-space:nowrap">percentage:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../Float.html">Float</a> = 25,</span> <span style="white-space:nowrap">whiteNoiseRange:<a class="type" title="vision.ds.specifics.WhiteNoiseRange" href="../vision/ds/specifics/WhiteNoiseRange.html">WhiteNoiseRange</a> = RANGE_16</span>):<a class="type" title="vision.ds.Image - Represents a 2D image, as a matrix of Colors." href="../vision/ds/Image.html">Image</a></code></h3><div class="doc"><p>Applies white noise to an image. White noise is the "snow" screen you see on televisions when they pick up unwanted electric/radiated electromagnetic signals instead of the channels you want to watch.</p>
<p>Instead of applying white noise every couple of pixels, white noise is sort of "combined" with the image, according to <code>percentage</code>:</p><table><thead><th>Original</th><th>Processed</th></thead><tbody><tr><td><img src="https://spacebubble.io/vision/docs/valve-original.png" alt="Before" /></td><td><img src="https://spacebubble.io/vision/docs/valve-whiteNoise.png" alt="After" /></td></tr></tbody></table><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>image</code></th><td><p>The image to apply salt&amp;pepper noise on</p></td></tr><tr><th style="width:25%;"><code>percentage</code></th><td><p>How white-noisy the resulting image should be, or, the ratio between the contributions of each pixel from the original image and the white noise to the final image, from 0 to 100: a lower value will make the first image's pixels contribute more to the the final image, thus making the resulting image less noisy, and vice-versa.</p></td></tr><tr><th style="width:25%;"><code>whiteNoiseRange</code></th><td><p>The number of shades of gray used to generate the white noise. Shouldn't really effect performance, but you may want to change it to get a "higher/lower quality" white noise.</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The noisy image. The original copy is not preserved.</p></div></div></div></div></div></div></div></div><footer class="section site-footer" style="background:#FAFAFA"><div class="container"><div class="copyright"><p style="color:#000000">&copy; 2024 &nbsp;</p></div></div></footer><script src="..//highlighter.js"></script><link href="../highlighter.css" rel="stylesheet"/></body></html>