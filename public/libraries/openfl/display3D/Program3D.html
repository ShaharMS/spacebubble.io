<!DOCTYPE html>
<html lang="en"><!-- use theme color or fallback -->
<!--use textcolor from settings, otherwise create a contrasting color to theme color-->
<head><meta charset="utf-8"/><link href="../../bootstrap/css/bootstrap.min.css" rel="stylesheet"/><link href="../../bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet"/><link href="../../bootstrap/css/bootstrap-select.min.css" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700,700italic,400italic" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600,600italic,400" rel="stylesheet" type="text/css"/><link href="https://netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.css" rel="stylesheet" type="text/css"/><script src="../../jquery-3.6.0.min.js"></script><script src="../../bootstrap/js/bootstrap.min.js"></script><script src="../../bootstrap/js/bootstrap-select.min.js"></script><link href="../../styles.css" rel="stylesheet"/><link href="../../extra-styles.css" rel="stylesheet"/><link href="../../haxe-nav.css" rel="stylesheet"/><link href="../../dark-mode.css" rel="stylesheet"/><script>var dox = {rootPath: "../../",platforms: ["oc"]};</script><script src="../../nav.js"></script><script src="../../index.js"></script><link rel="icon" href="../../favicon.ico" type="image/x-icon"/><title>openfl.display3D.Program3D</title><meta name="description" content="The Program3D class represents a pair of rendering programs (also called &quot;shaders&quot;)
uploaded to the rendering context."/></head><body><script>/* Here to prevent flash of unstyled content */let systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;if ((!localStorage.theme && systemDarkMode) || localStorage.theme == "dark") {document.body.style.backgroundColor = "#111";document.body.style.opacity = "0";document.addEventListener("DOMContentLoaded", function(event) {toggleTheme();document.body.style.backgroundColor = "";document.body.style.opacity = "";});}</script><style>
.navbar .brand {
	display: inline-block;
	float: none;
	text-shadow: 0 0 0 transparent;
}
</style><nav class="nav"><div class="navbar"><div class="navbar-inner" style="background:#FAFAFA; border-bottom:1px solid rgba(0,0,0,.09)"><div class="container"><a class="brand" style="color:#000000" href="../../">API Documentation</a><a href="#" id="theme-toggle" class="brand" style="color:#000000" onclick="toggleTheme()" title="Toggle Dark Mode"><i class="fa fa-moon-o"></i></a></div></div></div></nav><div class="container main-content"><div class="row-fluid"><div class="span3"><div class="well sidebar-nav"><form class="form-search" id="searchForm"><div class="input-prepend input-block-level"><span class="add-on"><i class="fa fa-search"></i></span><input id="search" type="text" placeholder="Filter (Ctrl+P)" autocomplete="off"/></div></form></div><div class="well sidebar-nav" id="explorer"><div id="nav"></div></div></div><div class="span9"><div class="page-header"><h1><small>final class</small> Program3D</h1><h4><small>package <a href="../../openfl/display3D/index.html">openfl.display3D</a></small></h4>    <span class="label label-meta label-meta-directlyUsed" title="Marks types that are directly referenced by non-extern code.">@:directlyUsed</span><span class="label label-meta label-meta-fileXml" title="Include a given XML attribute snippet in the `Build.xml` entry for the file.">@:fileXml(&quot;tags=\&quot;haxe,release\&quot;&quot;)</span><span class="label label-meta label-meta-noDebug" title="Does not generate debug information even if `--debug` is set.">@:noDebug</span><span class="label label-meta label-meta-access" title="Forces private access to package, type or field.">@:access(openfl.display3D.Context3D)</span><span class="label label-meta label-meta-access" title="Forces private access to package, type or field.">@:access(openfl.display.ShaderInput)</span><span class="label label-meta label-meta-access" title="Forces private access to package, type or field.">@:access(openfl.display.ShaderParameter)</span><span class="label label-meta label-meta-access" title="Forces private access to package, type or field.">@:access(openfl.display.Stage)</span><span class="label label-meta label-meta-final" title="Prevents a class or interface from being extended or a method from being overridden. Deprecated by the keyword `final`.">@:final</span></div><div class="body"><div class="doc doc-main"><p>The Program3D class represents a pair of rendering programs (also called "shaders")
uploaded to the rendering context.</p>
<p>Programs managed by a Program3D object control the entire rendering of triangles
during a Context3D drawTriangles() call. Upload the binary bytecode to the rendering
context using the upload method. (Once uploaded, the program in the original byte
array is no longer referenced; changing or discarding the source byte array does
not change the program.)</p>
<p>Programs always consist of two linked parts: A vertex and a fragment program.</p><ol><li>The vertex program operates on data defined in VertexBuffer3D objects and is
responsible for projecting vertices into clip space and passing any required vertex
data, such as color, to the fragment shader.</li><li>The fragment shader operates on the attributes passed to it by the vertex program
and produces a color for every rasterized fragment of a triangle, resulting in pixel
colors. Note that fragment programs have several names in 3D programming literature,
including fragment shader and pixel shader.</li></ol>
<p>Designate which program pair to use for subsequent rendering operations by passing the
corresponding Program3D instance to the Context3D <code>setProgram()</code> method.</p>
<p>You cannot create a Program3D object directly; use the Context3D <code>createProgram()</code>
method instead.</p></div><h3 class="section">Methods</h3><div class="fields"><div class="field "><a name="dispose"></a><h3 class="anchor"><code><a href="#dispose"><span class="identifier">dispose</span></a>():<a class="type" title="Void - The standard Void type." href="../../Void.html">Void</a></code></h3><div class="doc"><p>Frees all resources associated with this object. After disposing a
Program3D object, calling <code>upload()</code> and rendering using this object will fail.</p></div></div><div class="field "><a name="getAttributeIndex"></a><h3 class="anchor"><code><a href="#getAttributeIndex"><span class="identifier">getAttributeIndex</span></a>(<span style="white-space:nowrap">name:<a class="type" title="String - The basic String class." href="../../String.html">String</a></span>):<a class="type" title="Int - The standard Int type." href="../../Int.html">Int</a></code></h3><div class="doc"><p>BETA**</p>
<p>Get the index for the specified shader attribute.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The index, or -1 if the attribute is not bound or
was not found in the shader sources</p></div></div></div><div class="field "><a name="getConstantIndex"></a><h3 class="anchor"><code><a href="#getConstantIndex"><span class="identifier">getConstantIndex</span></a>(<span style="white-space:nowrap">name:<a class="type" title="String - The basic String class." href="../../String.html">String</a></span>):<a class="type" title="Int - The standard Int type." href="../../Int.html">Int</a></code></h3><div class="doc"><p>BETA**</p>
<p>Get the index for the specified shader constant.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The index, or -1 if the constant is not bound or
was not found in the shader sources</p></div></div></div><div class="field "><a name="upload"></a><h3 class="anchor"><code><a href="#upload"><span class="identifier">upload</span></a>(<span style="white-space:nowrap">vertexProgram:<a class="type" title="openfl.utils.ByteArray - The ByteArray class provides methods and properties to optimize reading, writing, and working with binary data." href="../../openfl/utils/ByteArray.html">ByteArray</a>,</span> <span style="white-space:nowrap">fragmentProgram:<a class="type" title="openfl.utils.ByteArray - The ByteArray class provides methods and properties to optimize reading, writing, and working with binary data." href="../../openfl/utils/ByteArray.html">ByteArray</a></span>):<a class="type" title="Void - The standard Void type." href="../../Void.html">Void</a></code></h3><div class="doc"><p>Uploads a pair of rendering programs expressed in AGAL (Adobe Graphics Assembly
Language) bytecode.</p>
<p>Program bytecode can be created using the Pixel Bender 3D offline tools. It can
also be created dynamically. The AGALMiniAssembler class is a utility class
that compiles AGAL assembly language programs to AGAL bytecode. The class is not
part of the runtime. When you upload the shader programs, the bytecode is
compiled into the native shader language for the current device (for example,
OpenGL or Direct3D). The runtime validates the bytecode on upload.</p>
<p>The programs run whenever the Context3D <code>drawTriangles()</code> method is invoked. The
vertex program is executed once for each vertex in the list of triangles to be
drawn. The fragment program is executed once for each pixel on a triangle surface.</p>
<p>The "variables" used by a shader program are called registers. The following
registers are defined:</p><table><thead><th>Name</th><th>Number per Fragment program</th><th>Number per Vertex program</th><th>Purpose</th></thead><tbody><tr><td>Attribute</td><td>n/a</td><td>8</td><td>Vertex shader input; read from a vertex buffer specified using <code><a href="../../openfl/display3D/Context3D.html#setVertexBufferAt">Context3D.setVertexBufferAt</a>()</code>.</td></tr><tr><td>Constant</td><td>28</td><td>128</td><td>Shader input; set using the <code><a href="../../openfl/display3D/Context3D.html#setProgramConstants">Context3D.setProgramConstants</a>()</code> family of functions.</td></tr><tr><td>Temporary</td><td>8</td><td>8</td><td>Temporary register for computation, not accessible outside program.</td></tr><tr><td>Output</td><td>1</td><td>1</td><td>Shader output: in a vertex program, the output is the clipspace position; in a fragment program, the output is a color.</td></tr><tr><td>Varying</td><td>8</td><td>8</td><td>Transfer interpolated data between vertex and fragment shaders. The varying registers from the vertex program are applied as input to the fragment program. Values are interpolated according to the distance from the triangle vertices.</td></tr><tr><td>Sampler</td><td>8</td><td>n/a</td><td>Fragment shader input; read from a texture specified using <code><a href="../../openfl/display3D/Context3D.html#setTextureAt">Context3D.setTextureAt</a>()</code></td></tr></tbody></table>
<p>A vertex program receives input from two sources: vertex buffers and constant
registers. Specify which vertex data to use for a particular vertex attribute
register using the Context3D <code>setVertexBufferAt()</code> method. You can define up to
eight input registers for vertex attributes. The vertex attribute values are read
from the vertex buffer for each vertex in the triangle list and placed in the
attribute register. Specify constant registers using the Context3D
<code>setProgramConstantsFromMatrix()</code> or <code>setProgramConstantsFromVector()</code>
methods. Constant registers retain the same value for every vertex in the
triangle list. (You can only modify the constant values between calls to
<code>drawTriangles().</code>)</p>
<p>The vertex program is responsible for projecting the triangle vertices into
clip space (the canonical viewing area within ±1 on the x and y axes and 0-1 on
the z axis) and placing the transformed coordinates in its output register.
(Typically, the appropriate projection matrix is provided to the shader in a set
of constant registers.) The vertex program must also copy any vertex attributes
or computed values needed by the fragment program to a special set of variables
called varying registers. When a fragment shader runs, the value supplied in a
varying register is linearly interpolated according to the distance of the
current fragment from each triangle vertex.</p>
<p>A fragment program receives input from the varying registers and from a separate
set of constant registers (set with <code>setProgramConstantsFromMatrix()</code> or
<code>setProgramConstantsFromVector()</code>). You can also read texture data from textures
uploaded to the rendering context using sampler registers. Specify which texture
to access with a particular sampler register using the Context3D <code>setTextureAt()</code>
method. The fragment program is responsible for setting its output register to a
color value.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>vertexProgram</code></th><td><p>AGAL bytecode for the Vertex program. The ByteArray object
must use the little endian format.</p></td></tr><tr><th style="width:25%;"><code>fragmentProgram</code></th><td><p>AGAL bytecode for the Fragment program. The ByteArray
object must use the little endian format.</p></td></tr></table><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>TypeError</code></th><td><p>Null Pointer Error: if vertexProgram or fragmentProgram is
<code>null</code>.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Object Disposed: if the Program3D object was disposed either
directly by a call to <code>dispose()</code>, or indirectly by calling the Context3D
<code>dispose()</code> or because the rendering context was disposed because of device loss.</p></td></tr><tr class="indent"><th style="width:25%;"><code>ArgumentError</code></th><td><p>Agal Program Too Small: when either program code array
is smaller than 31 bytes length. This is the size of the shader bytecode of a
one-instruction program.</p></td></tr><tr class="indent"><th style="width:25%;"><code>ArgumentError</code></th><td><p>Program Must Be Little Endian: if either of the program
byte code arrays is not little endian.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Native Shader Compilation Failed: if the output of the AGAL
translator is not a compilable native shader language program. This error is only
thrown in release players.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Native Shader Compilation Failed OpenGL: if the output of the
AGAL translator is not a compilable OpengGL shader language program, and
includes compilation diagnostics. This error is only thrown in debug players.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Native Shader Compilation Failed D3D9: if the output of the AGAL
translator is not a compilable Direct3D shader language program, and includes
compilation diagnostics. This error is only thrown in debug players.
The following errors are thrown when the AGAL bytecode validation fails:</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Not An Agal Program: if the header "magic byte" is wrong. The
first byte of the bytecode must be 0xa0. This error can indicate that the byte
array is set to the wrong endian order.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Bad Agal Version: if the AGAL version is not supported by the
current SWF version. The AGAL version must be set to 1 for SWF version 13.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Bad Agal Program Type: if the AGAL program type identifier is
not valid. The third byte in the byte code must be 0xa1. This error can indicates
that the byte array is set to the wrong endian order.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Bad Agal Shader Type: if the shader type code is not either
fragment or vertex (1 or 0).</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Invalid Agal Opcode Out Of Range: if an invalid opcode is
encountered in the token stream.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Invalid Agal Opcode Not Implemented: if an invalid opcode is
encountered in the token stream.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Agal Opcode Only Allowed In Fragment Program: if an opcode is
encountered in the token stream of the vertex program that is only allowed in fragment programs, such as KIL or TEX.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Bad Agal Source Operands: if both source operands are constant
registers. You must compute the result outside the shader program and pass it
in using a single constant register.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Both Operands Are Indirect Reads: if both operands are indirect
reads.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Opcode Destination Must Be All Zero: if a token with an opcode
(such as KIL) that has no destination sets a non-zero value for the destination
register.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Opcode Destination Must Use Mask: if an opcode that produces
only a 3 component result is used without masking.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Too Many Tokens: if there are too many tokens (more than 200) in
an AGAL program.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Fragment Shader Type: if the fragment program type (byte 6 of
fragmentProgram parameter) is not set to 1.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Vertex Shader Type: if the vertex program type (byte 6 of
vertexProgram parameter) is not set to 0.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Varying Read But Not Written To: if the fragment shader reads a
varying register that was never written to by the vertex shader.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Varying Partial Write: if a varying register is only partially
written to. All components of a varying register must be written to.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Fragment Write All Components: if a fragment color output is only
partially written to. All four components of the color output must be written to.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Vertex Write All Components: if a vertex clip space output is only
partially written to. All components of the vertex clip space output must be
written to.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Unused Operand: if an unused operand in a token is not set to all
zero.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Sampler Register Only In Fragment: if a texture sampler register
is used in a vertex program.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Sampler Register Second Operand: if a sampler register is used
as a destination or first operand of an AGAL token.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Indirect Only Allowed In Vertex: if indirect addressing is used
in a fragment program.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Indirect Only Into Constant Registers: if indirect addressing
is used on a non-constant register.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Indirect Source Type: if the indirect source type is not
attribute, constant or temporary register.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Indirect Addressing Fields Must Be Zero: if not all indirect
addressing fields are zero for direct addressing.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Varying Registers Only Read In Fragment: if a varying register is
read in a vertex program. Varying registers can only be written in vertex
programs and read in fragment programs.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Attribute Registers Only Read In Vertex: if an attribute
registers is read in a fragment program. Attribute registers can only be read
in vertex programs.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Can Not Read Output Register: if an output (position or color)
register is read. Output registers can only be written to, not read.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Temp Register Read Without Write: if a temporary register is read
without being written to earlier.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Temp Register Component Read Without Write: if a specific
temporary register component is read without being written to earlier.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Sampler Register Cannot Be Written To: if a sampler register is
written to. Sampler registers can only be read, not written to.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Varying Registers Write: if a varying register is written to in
a fragment program. Varying registers can only be written in vertex programs and
read in fragment programs.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Attribute Register Cannot Be Written To: if an attribute
register is written to. Attribute registers are read-only.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Constant Register Cannot Be Written To: if a constant register
is written to inside a shader program.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Destination Writemask Is Zero: if a destination writemask is
zero. All components of an output register must be set.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>AGAL Reserved Bits Should Be Zero: if any reserved bits in a
token are not zero. This indicates an error in creating the bytecode (or
malformed bytecode).</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Unknown Register Type: if an invalid register type index is used.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Sampler Register Out Of Bounds: if an invalid sampler register
index is used.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Varying Register Out Of Bounds: if an invalid varying register
index is used.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Attribute Register Out Of Bounds: if an invalid attribute
register index is used.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Constant Register Out Of Bounds: if an invalid constant
register index is used.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Output Register Out Of Bounds: if an invalid output register
index is used.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Temporary Register Out Of Bounds: if an invalid temporary
register index is used.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Cube Map Sampler Must Use Clamp: if a cube map sampler does not
set the wrap mode to clamp.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Unknown Sampler Dimension: if a sample uses an unknown sampler
dimension. (Only 2D and cube textures are supported.)</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Unknown Filter Mode: if a sampler uses an unknown filter mode.
(Only nearest neighbor and linear filtering are supported.)</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Unknown Mipmap Mode: if a sampler uses an unknown mipmap mode.
(Only none, nearest neighbor, and linear mipmap modes are supported.)</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Unknown Wrapping Mode if a sampler uses an unknown wrapping mode.
(Only clamp and repeat wrapping modes are supported.)</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Unknown Special Flag: if a sampler uses an unknown special flag.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Output Color Not Maskable: You cannot mask the color output
register in a fragment program. All components of the color register must be set.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Second Operand Must Be Sampler Register: The AGAL tex opcode must
have a sampler as the second source operand.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Indirect Not Allowed: indirect addressing used where not allowed.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Swizzle Must Be Scalar: swizzling error.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Cant Swizzle 2nd Source: swizzling error.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>Second Use Of Sampler Must Have Same Params: all samplers that
access the same texture must use the same dimension, wrap, filter, special, and
mipmap settings.</p></td></tr><tr class="indent"><th style="width:25%;"><code>Error</code></th><td><p>3768: The Stage3D API may not be used during background execution.</p></td></tr></table></div></div><div class="field "><a name="uploadSources"></a><h3 class="anchor"><code><a href="#uploadSources"><span class="identifier">uploadSources</span></a>(<span style="white-space:nowrap">vertexSource:<a class="type" title="String - The basic String class." href="../../String.html">String</a>,</span> <span style="white-space:nowrap">fragmentSource:<a class="type" title="String - The basic String class." href="../../String.html">String</a></span>):<a class="type" title="Void - The standard Void type." href="../../Void.html">Void</a></code></h3><div class="doc"><p>BETA**</p>
<p>Uploads a pair of rendering programs expressed in GLSL (GL Shader Language).</p></div></div></div></div></div></div></div><footer class="section site-footer" style="background:#FAFAFA"><div class="container"><div class="copyright"><p style="color:#000000">&copy; 2022 &nbsp;</p></div></div></footer><script src="../..//highlighter.js"></script><link href="../../highlighter.css" rel="stylesheet"/></body></html>